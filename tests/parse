#!/usr/bin/perl

# ---   *   ---   *   ---
# deps

  use v5.36.0;
  use strict;
  use warnings;

  use English qw(-no_match_vars);

  use lib $ENV{'ARPATH'}.'/lib/sys/';

  use Style;
  use Arstd::IO;

  use Cli;

  use lib $ENV{'ARPATH'}.'/lib/';

  use Emit::Std;
  use Emit::C;

  use Peso::Rd;
  use Lang::SinGL;

# ---   *   ---   *   ---
# info

  our $VERSION = v0.02.0;
  our $AUTHOR  = 'IBN-3DILA';

# ---   *   ---   *   ---
# command line

  my $M=Cli->nit(

    @{$Cli::Fstruct::ATTRS},

    {id=>'inc',short=>'-I',argc=>1},
    {id=>'out',short=>'-o',argc=>1},

    {id=>'echo',short=>'-e',argc=>0},

  );

# ---   *   ---   *   ---
# ROM

  my $EXTERN_RE=qr{^\s*\#include\s+
    <([^>]+)>

  $}x;

  my $UNIFORM_RE = qr{^uniform$}x;
  my $LAYOUT_RE  = qr{^layout$}x;
  my $BUFFER_RE  = qr{^buffer$}x;

  my $SAMPLER_RE = qr{^sampler}x;

# ---   *   ---   *   ---
# GBL

  my ($Rd,$Vert,$Frag,$Tree);

  my @Out_Lines=();
  my %Out_Include=();

# ---   *   ---   *   ---
# shader attrs

sub get_vert_inputs() {

  state $re=qr{^in$}x;
  return $Vert->branches_in($re);

};

# ---   *   ---   *   ---
# vert out to frag in

sub get_vert_outputs() {

  state $f_re=qr{^((flat \s out)|out)$}x;
  state $o_re=qr{out}x;

  my @branches=$Vert->branches_in($f_re);

  for my $branch(reverse @branches) {

    my $cpy=$branch->dup();

    $cpy->deep_value_repl($o_re,'in');
    $Frag->insert(0,'blank');
    $cpy->insert(int(@{$cpy->{leaves}}),';');

    $Frag->{leaves}->[0]->repl($cpy);

  };

  return @branches;

};

# ---   *   ---   *   ---
# get uniforms cross-shader

sub get_program_uniforms() {

  my @branches=$Tree->branches_in($UNIFORM_RE);

  return grep {

     @{$ARG->{leaves}}>0
  && !defined $ARG->branch_in($SAMPLER_RE)

  } @branches;

};

# ---   *   ---   *   ---
# ^ubos

sub get_program_ubos() {

  my @branches=$Tree->branches_in($LAYOUT_RE);

  return grep {
    defined $ARG->branch_in($UNIFORM_RE)

  } @branches;

};

# ---   *   ---   *   ---
# ^ssbos

sub get_program_ssbos() {

  my @branches=$Tree->branches_in($LAYOUT_RE);

  return grep {
    defined $ARG->branch_in($BUFFER_RE)

  } @branches;

};

# ---   *   ---   *   ---
# get samplers from fragment shader
# NOTE: untested!

sub get_frag_samplers() {

  my @branches=$Frag->branches_in($UNIFORM_RE);

  return grep {

     @{$ARG->{leaves}}>0
  && defined $ARG->branch_in($SAMPLER_RE)

  } @branches;

};

# ---   *   ---   *   ---
# get list of external sources

sub get_extern($shader) {

  my @branches=$shader->branches_in($EXTERN_RE);

  for my $branch(@branches) {

    $branch=$branch->{value};
    $branch=~ s[$EXTERN_RE][$1];

    chomp $branch;

    if($branch eq 'version') {
      next;

    };

# ---   *   ---   *   ---
# get header for include in out file

    my $header=$branch;
    $header=~ s[/][_]sxmg;

    my $found=Shb7::ffind("$header",'hpp');

    errout(
      q[Header file not found for <%s>],

      args=>[$header],
      lvl=>$AR_FATAL

    ) unless $found;

    if(!exists $Out_Include{$found}) {

      $found="\"$found\"";
      $Out_Include{$found}=1;

    };

# ---   *   ---   *   ---
# get real name of shader

    $found=Shb7::ffind("$branch",'sg');

    errout(
      q[Shader file not found for <%s>],

      args=>[$branch],
      lvl=>$AR_FATAL

    ) unless $found;

    $branch=$found;
    $branch=~ s[\..+$][];
    $branch=~ s[/][_]sxmg;

# ---   *   ---   *   ---

  };

  my $ext=($shader==$Frag)
    ? '_frag'
    : '_vert'
    ;

  return map {
    '      shader::'."$ARG".$ext

  } @branches;

};

# ---   *   ---   *   ---
# writes out tree to C++ raw string

sub make_src($name,$src) {

  state $vauth_re=qr{^(?:VERSION|AUTHOR)$};

  push @Out_Lines,"  const char* $name=R\"glsl(";

  my $out     = $NULLSTR;
  my @pending = @{$src->{leaves}};

  while(@pending) {

    my $branch=shift @pending;

# ---   *   ---   *   ---
# strip #include directive

    if($branch->{value}=~ $EXTERN_RE) {
      next;

# ---   *   ---   *   ---
# strip version and author directives

    } elsif($branch->{value}=~ $vauth_re) {

      while(

          @pending
      &&  $pending[0]->{value} ne ';'

      ) {shift @pending};

      shift @pending;next;

    };

# ---   *   ---   *   ---
# convert tree branch to text

    my $code=$branch->to_string(
      keep_root=>1

    );

    $out.='    '.$code;

# ---   *   ---   *   ---
# apply formatting
# yes.

  };

  owc("./tmp_code.fmat",$out);

  my $call = $ENV{'ARPATH'}.'/bitter/bin/fmat';
  $out     = `$call "./tmp_code.fmat"`;

  unlink("./tmp_code.fmat");

  # i love perl
  $out=(join "\n",(

    map {$ARG="    $ARG"}
    (split $NEWLINE_RE,$out)

  ));

  # spit it out
  push @Out_Lines,"$out\n\n  )glsl\"\n";

};

# ---   *   ---   *   ---
# makes list of source strings

sub src_list($name,$type) {

  my $tree=($type eq 'v') ? $Vert : $Frag;

  my @sources=get_extern($tree);
  push @sources,"      $name";

  push @Out_Lines,

    "    .source_$type={\n",
    (join ",\n",@sources),

    "\n\n    },\n"

  ;

  push @Out_Lines,

    "    .source_${type}_sz=".
    int(@sources).",\n"

  ;

};

# ---   *   ---   *   ---
# gets AUTHOR field of sin shader

sub get_author() {

  my $out='ANON';
  my $b=$Vert->branch_in(qr{^AUTHOR$});

  if($b) {
    $out=$b->{leaves}->[-1]->{value};
    $out=~ s["][]sxgm;

  };

  return $out;

};

# ---   *   ---   *   ---
# generic attr list

sub obj_list($name,$fn) {

  my @ar=map {q[  "].
    $ARG->{leaves}->[-1]->{value}.

  q["]} $fn->();

  push @Out_Lines,

    "    .$name={\n    ",
    (join ",\n    ",@ar),

    "\n\n    },\n"

  ;

  push @Out_Lines,

    "    .num_$name=".
    int(@ar).",\n"

  ;

};

# ---   *   ---   *   ---
# assemble shader params

sub asm($name) {

  get_vert_outputs();

  my $v_name="${name}_vert";
  my $f_name="${name}_frag";

  push @Out_Lines,"namespace shader {\n";

  make_src($v_name,$Vert);
  make_src($f_name,$Frag);

  push @Out_Lines,"\n// ---   *   ---   *   ---\n";
  push @Out_Lines,"  const Params $name={\n";

  src_list($v_name,'v');
  src_list($f_name,'f');

# ---   *   ---   *   ---

  obj_list('attrs',\&get_vert_inputs);

  obj_list('uniforms',\&get_program_uniforms);
  obj_list('ubos',\&get_program_ubos);
  obj_list('ssbos',\&get_program_ssbos);

  obj_list('samplers',\&get_frag_samplers);

# ---   *   ---   *   ---

  push @Out_Lines,"\n\n  };\n\n};\n";
  push @Out_Lines,"\n// ---   *   ---   *   ---\n";

};

# ---   *   ---   *   ---
# get command line args

my @Files=Cli::Fstruct::proto_search($M);

# get path
my @Includes=($M->{inc} ne $NULL)
  ? split $COMMA_RE,$M->{inc}
  : ()
  ;

# ^set
Shb7::stinc(
  $ENV{'ARPATH'}.'/sin/',
  $ENV{'ARPATH'}.'/sin/glsl/',
  $ENV{'ARPATH'}.'/sin/glsl/blocks/',

  @Includes

);

# ---   *   ---   *   ---
# get output dir

my $Out_Dir=($M->{out} ne $NULL)
  ? $M->{out}
  : glob('./')
  ;

# ^catch
errout(

  q[Not a directory: %s],

  args=>[$Out_Dir],
  lvl=>$AR_FATAL

) unless -d $Out_Dir;

# ---   *   ---   *   ---
# main loop

for my $fname(@Files) {

  $Rd=Peso::Rd::parse(
    Lang->SinGL,$fname

  );

  ($Vert,$Frag)=Lang->SinGL->hier_sort($Rd);
  $Tree=$Rd->select_block(-ROOT)->{tree};

  my $name=$fname;
  $name=~ s[\..+$][];
  $name=~ s[/][_]sxmg;

  asm($name);

# ---   *   ---   *   ---
# create hpp file

  my %O=(

    add_guards=>1,

    include=>[
      '"sin/shader/Params.hpp"',
      keys %Out_Include

    ],

    define=>[],

    author=>get_author(),

  );

  unshift @Out_Lines,
    Emit::C->boiler_open($name,%O);

  push @Out_Lines,
    Emit::C->boiler_close($name,%O);

# ---   *   ---   *   ---
# spit it

  my $out=join $NULLSTR,@Out_Lines;

  if($M->{echo} eq $NULL) {
    owc("$Out_Dir/$name.hpp",$out);

  } else {
    say $out;

  };

};

# ---   *   ---   *   ---
1; # ret

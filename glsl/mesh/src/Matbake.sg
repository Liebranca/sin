// ---   *   ---   *   ---
// MATBAKE
// Crackhead levels of
// render to texture
//
// LIBRE SOFTWARE
// Licensed under GNU GPL3
// be a bro and inherit
//
// CONTRIBUTORS
// lyeb,

// ---   *   ---   *   ---
// info

$:VERT;>

  VERSION   v0.00.4b;
  AUTHOR    "IBN-3DILA";

// ---   *   ---   *   ---
// deps

  #include <mesh/CRK_Angular>

  out vec3  Normal;
  out vec4  Point;
  out mat3  IV_TBN;

  out float Vert_Light;
  out float Vert_AO;

// ---   *   ---   *   ---

void main(void) {

  vec4 co     = extract_xyz();
  vec3 n      = extract_n();

  IV_TBN      = transpose(extract_tbn());

  Normal      = apply_nmat(n);
  Point       = co;

  Tex_Cords   = extract_tex();
  gl_Position = apply_transform(co);

//  gl_Position = vec4(
//
//    (Tex_Cords.x-0.5)*2,
//    (Tex_Cords.y-0.5)*2,
//
//    0,1
//
//  );

  fDraw_ID    = Draw_Data[0];
  fSurf_ID    = Draw_Data[1];

  unpack_view();

  Cam_Fwd     = IV_TBN * Cam_Fwd;
  Vert_Light  = vl_smooth(IV_TBN * Normal);

  Vert_AO     =float(

    (Vertex[1] >> 24)
  & uint(0xFF)

  ) * 0.003921f;

};

// ---   *   ---   *   ---
// deps

$:FRAG;>

  #include <mesh/CRK_Angular>

// ---   *   ---   *   ---
// inputs

  uniform sampler2DArray Surface;

// ---   *   ---   *   ---
// outputs

  out vec4 Frag_Color;

// ---   *   ---   *   ---
// ROM

  const vec3 Y_AXIS=vec3(0,1,0);
  const vec3 Y_VOID=vec3(-1,1,0);

// ---   *   ---   *   ---
// src: yiwenl/glsl-rotation-2d
// added (approx) deg2rad

vec2 rotate(vec2 v, float a) {

  a*=0.0174533f;

  float s = sin(a);
  float c = cos(a);

  mat2  m = mat2(c,-s,s,c);

	return m * v;

};

// ---   *   ---   *   ---
// normal ipol mask

vec2 nipol(void) {

  float aby    = abs(Normal.y);
  float abx    = abs(Normal.x) + abs(Normal.z);
  float step   = 0.5f * float(aby < 0.5f);

  float treshy = smoothstep(0.35f,1,aby);
  float treshx = 1-smoothstep(0,1*step,aby);

  float fay=normalize(aby)*treshy;
  float fax=normalize(abx)*treshx;

  return vec2(fax,fay);

};

// ---   *   ---   *   ---
// uv tax evation

vec4 boxmapping(void) {

  vec2 uvy=rotate(Point.zx,45);

  vec4 x=texture(Surface,vec3(Point.zy,Tex_Cords.z));
  vec4 y=texture(Surface,vec3(uvy,Tex_Cords.z));
  vec2 f=nipol();

  return (x*f.x + y*f.y) / (f.x+f.y);

};

// ---   *   ---   *   ---
// determine height from color (yes)

vec4 heightmap(vec4 color) {

  // color to grayscale
  float luma=
    0.257f*color.r
  + 0.504f*color.g
  + 0.098f*color.b
  ;

  float iv_luma=1-luma;

  // find arbitrary up
  const vec3 axes[]={Y_AXIS,Y_VOID};
  vec3 yax=axes[uint(abs(Normal.y) >= 0.99f)];

  // ^get local up
  vec3 hax = cross(Normal,yax);
  vec3 up  = cross(Normal,hax);
  vec3 fwd = cross(Normal,up);

  // scale vectors by inverse height
  hax *= iv_luma * 2.00f;
  up  *= iv_luma * 2.00f;
  fwd *= iv_luma * 0.50f;

  // ^solve by aversion to matmul
  vec3 push=(up+yax)-(Normal-fwd)-hax;
  vec3 n=normalize(IV_TBN * (Normal-push));

  n.xy*=luma;

  return vec4(n,luma);

};

// ---   *   ---   *   ---
// ^roughness from height

float roughness(vec4 height) {

  float fac=clamp(
    (1-abs(height.x))
  * (1-abs(height.y)),

    0,1

  );

  return fac*height.z*(1-height.w);

};

// ---   *   ---   *   ---
// approximate AO from heightmap
// by averaging dot-eye across
// a multitude of normals

float AO(vec4 height) {

  float d=0.0f;
  const float zenith[]={
    -2.0f,-0.25f,2.0f

  };

  for(int y=0;y<3;y++) {

  for(int x=0;x<5;x++) {
  for(int z=0;z<5;z++) {

    vec3 n=normalize(

      IV_TBN * vec3(
        (x-2)*0.5f,
        zenith[y],

        (z-2)*0.5f

      )

    );

    d+=max(0,dot(
      n,height.xyz

    ) * height.w * 2.0f);

  }}};

  return clamp((d/75)*2.0f,0,1);

};

// ---   *   ---   *   ---
// shading trick: do not raytrace

float tight_AO(vec4 height) {

  float ao=smoothstep(

    0,
    0.25f,

    Vert_AO

  );

  ao=clamp(ao*smoothstep(

    0,
    0.65f,

    AO(height)

  ),0.00f,1.25f);

  return ao;

};

// ---   *   ---   *   ---

void main(void) {

  // [insert texgen schtick]

  vec4  color   = boxmapping();
  vec4  height  = heightmap(color);
  float ao      = tight_AO(height);
  float rough   = roughness(height);
  float soft    = 1-rough;

  // vec-to-eye
  vec3  vto    = Cam_Pos-vec3(Point);
  vec3  iv_vto = vec3(Point)-Cam_Pos;

  // ^to tangent space
  vto    = IV_TBN * normalize(vto);
  iv_vto = IV_TBN * normalize(iv_vto);

  // controls dot eye
  vec3 refl=reflect(Cam_Fwd,height.xyz);

  // ^derive
  float d=clamp(
    dot(iv_vto,refl)
  * 2.0f * height.w,

    0,1

  );

  float iv_d=clamp(pow(
    dot(vto,refl)
  * 2.0f * height.w,

    2

  ),0,1);

  // ^expand
  float fresnel=smoothstep(

    0.0f,
    1.0f,

    clamp(iv_d-d,0,1)

  ) * 2.0f;

  float near = smoothstep(0,height.w,d) * 0.5f;
  float far  = smoothstep(height.w,1,d) * 4.0f;

  float vl   = clamp((near+far),0.0f,1.0f);

  // get colors
  vec3 ambient=
    vec3(0,0,0.25f) * 0.25f
  + vec3(0,0,0.25f) * fresnel

  ;

  vec3 diffuse=(
    color.rgb*Vert_Light
  + ambient

  ) * ao;

  vec3 specular=
    color.rgb*vl*(max(0.35f,ao*2.0f))
  * soft*2.0f
  ;

  Frag_Color=vec4(

    ambient

  + diffuse
  + specular,

    1

  );

//  Frag_Color=vec4(vec3((height.z*0.5f)+0.5f),1);

//  Frag_Color=vec4(vec3((Point*0.5f)+0.5f),1);

//  Frag_Color=vec4(vec3(ambient),1);

};

// ---   *   ---   *   ---

#!/usr/bin/perl
# ---   *   ---   *   ---
# SIN GL
# GLSL preprocessor
#
# LIBRE SOFTWARE
# Licensed under GNU GPL3
# be a bro and inherit
#
# CONTRIBUTORS
# lyeb,

# ---   *   ---   *   ---
# deps

  use v5.36.0;
  use strict;
  use warnings;

  use English qw(-no_match_vars);

  use lib $ENV{'ARPATH'}.'/lib/sys/';

  use Style;
  use Arstd::IO;

  use Cli;

  use lib $ENV{'ARPATH'}.'/lib/';

  use Emit::Std;
  use Emit::C;

  use Peso::Rd;
  use Lang::SinGL;

# ---   *   ---   *   ---
# info

  our $VERSION = v0.03.0;
  our $AUTHOR  = 'IBN-3DILA';

# ---   *   ---   *   ---
# command line

  my $M=Cli->nit(

    @{$Cli::Fstruct::ATTRS},

    {id=>'inc',short=>'-I',argc=>1},
    {id=>'out',short=>'-o',argc=>1},

    {id=>'echo',short=>'-e',argc=>0},

  );

# ---   *   ---   *   ---
# ROM

  my $EXTERN_RE=qr{^\s*\#include\s+
    <([^>]+)>

  $}x;

  my $UNIFORM_RE = qr{^uniform$}x;
  my $LAYOUT_RE  = qr{^layout$}x;
  my $BUFFER_RE  = qr{^buffer$}x;

  my $SAMPLER_RE = qr{^sampler}x;

# ---   *   ---   *   ---
# GBL

  my ($Rd,$Vert,$Frag,$Tree);

  my @Out_Lines=();
  my %Out_Include=();

# ---   *   ---   *   ---
# shader attrs

sub get_vert_inputs() {

  state $re=qr{^in$}x;
  return $Vert->branches_in($re);

};

# ---   *   ---   *   ---
# vert out to frag in

sub get_vert_outputs() {

  state $f_re=qr{^((flat \s out)|out)$}x;
  state $o_re=qr{out}x;

  my @branches=$Vert->branches_in($f_re);

  for my $branch(reverse @branches) {

    my $cpy=$branch->dup();

    $cpy->deep_value_repl($o_re,'in');
    $Frag->insert(0,'blank');
    $cpy->insert(int(@{$cpy->{leaves}}),';');

    $Frag->{leaves}->[0]->repl($cpy);

  };

  return @branches;

};

# ---   *   ---   *   ---
# get uniforms cross-shader

sub get_program_uniforms() {

  my @branches=$Tree->branches_in($UNIFORM_RE);

  return grep {

     @{$ARG->{leaves}}>0
  && !defined $ARG->branch_in($SAMPLER_RE)

  } @branches;

};

# ---   *   ---   *   ---
# ^ubos

sub get_program_ubos() {

  my @branches=$Tree->branches_in($LAYOUT_RE);

  return grep {
    defined $ARG->branch_in($UNIFORM_RE)

  } @branches;

};

# ---   *   ---   *   ---
# ^ssbos

sub get_program_ssbos() {

  my @branches=$Tree->branches_in($LAYOUT_RE);

  return grep {
    defined $ARG->branch_in($BUFFER_RE)

  } @branches;

};

# ---   *   ---   *   ---
# get samplers from fragment shader
# NOTE: untested!

sub get_frag_samplers() {

  my @branches=$Frag->branches_in($UNIFORM_RE);

  return grep {

     @{$ARG->{leaves}}>0
  && defined $ARG->branch_in($SAMPLER_RE)

  } @branches;

};

# ---   *   ---   *   ---
# get list of external sources

sub get_extern($shader) {

  my @branches=$shader->branches_in($EXTERN_RE);

  for my $branch(@branches) {

    $branch=$branch->{value};
    $branch=~ s[$EXTERN_RE][$1];

    chomp $branch;

    if($branch eq 'version') {
      next;

    };

# ---   *   ---   *   ---
# get header for include in out file

    my $header=$branch;
    my $found=Shb7::ffind("$header",'hpp');

    errout(
      q[Header file not found for <%s>],

      args=>[$header],
      lvl=>$AR_FATAL

    ) unless $found;

    if(!exists $Out_Include{$found}) {

      $found=Shb7::shpath($found);
      $found="\"$found\"";

      $Out_Include{$found}=1;

    };

# ---   *   ---   *   ---
# get real name of shader

    my @path=split m[/],$branch;
    my $name=pop @path;

    push @path,'src',$name;

    $found=Shb7::ffind((join q[/],@path),'sg');

    errout(
      q[Shader file not found for <%s>],

      args=>[$branch],
      lvl=>$AR_FATAL

    ) unless $found;

    $branch=~ s[\..+$][];
    $branch=~ s[/][::]sxmg;

# ---   *   ---   *   ---

  };

  my $ext=($shader==$Frag)
    ? '_frag'
    : '_vert'
    ;

  return map {
    '      shader::'."$ARG".$ext

  } @branches;

};

# ---   *   ---   *   ---
# writes out tree to C++ raw string

sub make_src($name,$src) {

  state $vauth_re=qr{^(?:VERSION|AUTHOR)$};

  push @Out_Lines,"  const char* $name=R\"glsl(";

  my $out     = $NULLSTR;
  my @pending = @{$src->{leaves}};

  while(@pending) {

    my $branch=shift @pending;

# ---   *   ---   *   ---
# strip #include directive

    if($branch->{value}=~ $EXTERN_RE) {
      next;

# ---   *   ---   *   ---
# strip version and author directives

    } elsif($branch->{value}=~ $vauth_re) {

      while(

          @pending
      &&  $pending[0]->{value} ne ';'

      ) {shift @pending};

      shift @pending;next;

    };

# ---   *   ---   *   ---
# convert tree branch to text

    my $code=$branch->to_string(
      keep_root=>1

    );

    $out.='    '.$code;

# ---   *   ---   *   ---
# apply formatting
# yes.

  };

  if(length $out) {
    owc("./tmp_code.fmat",$out);

    my $call = $ENV{'ARPATH'}.'/bitter/bin/fmat';
    $out     = `$call "./tmp_code.fmat"`;

    unlink("./tmp_code.fmat");

  };

  # spit it out
  push @Out_Lines,"$out\n\n  )glsl\";\n";
  push @Out_Lines,"\n// ---   *   ---   *   ---\n\n";

};

# ---   *   ---   *   ---
# makes list of source strings

sub src_list($name,$type) {

  my $tree=($type eq 'v') ? $Vert : $Frag;

  my @sources=get_extern($tree);
  push @sources,"      $name";

  push @Out_Lines,

    "    .source_$type={\n",
    (join ",\n",@sources),

    "    },"

  ;

  push @Out_Lines,

    "    .source_${type}_sz=".
    int(@sources).","

  ;

};

# ---   *   ---   *   ---
# gets AUTHOR field of sin shader

sub get_author() {

  my $out='ANON';
  my $b=$Vert->branch_in(qr{^AUTHOR$});

  if($b) {

    if(!@{$b->{leaves}}) {
      $out=$b->{parent}->{leaves}->[
        $b->{idex}+1

      ]->{value};

    } else {
      $out=$b->{leaves}->[-1]->{value};

    };

    $out=~ s["][]sxgm;

  };

  return $out;

};

# ---   *   ---   *   ---
# generic attr list

sub obj_list($name,$fn) {

  my @ar=map {q[      "].
    $ARG->{leaves}->[-1]->{value}.

  q["]} $fn->();

  push @Out_Lines,

    "    .$name={\n",
    (join ",\n      ",@ar),

    "    },"

  ;

  push @Out_Lines,

    "    .num_$name=".
    int(@ar).","

  ;

};

# ---   *   ---   *   ---
# assemble shader params

sub asm($name,$path) {

  get_vert_outputs();

  my $v_name="${name}_vert";
  my $f_name="${name}_frag";

  push @Out_Lines,
    'namespace shader::'.$path." {";

  make_src($v_name,$Vert);
  make_src($f_name,$Frag);

  push @Out_Lines,"  const Params $name={";

  src_list($v_name,'v');
  src_list($f_name,'f');

# ---   *   ---   *   ---

  obj_list('attrs',\&get_vert_inputs);

  obj_list('uniforms',\&get_program_uniforms);
  obj_list('ubos',\&get_program_ubos);
  obj_list('ssbos',\&get_program_ssbos);

  obj_list('samplers',\&get_frag_samplers);

# ---   *   ---   *   ---

  push @Out_Lines,"  };\n};\n";
  push @Out_Lines,"\n// ---   *   ---   *   ---\n";

};

# ---   *   ---   *   ---
# get command line args

my @Files=Cli::Fstruct::proto_search($M);

# get path
my @Includes=($M->{inc} ne $NULL)
  ? split $COMMA_RE,$M->{inc}
  : ()
  ;

# ^set
Shb7::stinc(
  $ENV{'ARPATH'}.'/sin/',
  @Includes

);

# ---   *   ---   *   ---
# get output dir

my $Out_Dir=($M->{out} ne $NULL)
  ? $M->{out}
  : glob('./')
  ;

# ^catch
errout(

  q[Not a directory: %s],

  args=>[$Out_Dir],
  lvl=>$AR_FATAL

) unless -d $Out_Dir;

# ---   *   ---   *   ---
# main loop

for my $fname(@Files) {

  $Rd=Peso::Rd::parse(
    Lang->SinGL,$fname

  );

  # set the siggy for later ;>
  my $v=(sprintf 'v%vd',$VERSION);
  my @v=split m[\.],$v;

  $v[1]='0'.$v[1] if length $v[1]==1;
  $v[2]='0'.$v[2] if length $v[2]==1;

  $v=join q[.],@v;

  my @sig=(
    "// SinGL $v",
    "// file assembled from $fname"

  );

# ---   *   ---   *   ---

  $fname=~ s[src/][];

  ($Vert,$Frag)=Lang->SinGL->hier_sort($Rd);
  $Tree=$Rd->select_block(-ROOT)->{tree};

  my $path=$fname;
  $path=~ s[\..+$][];
  $path=~ s[/][::]sxmg;

  my $name=$fname;
  $name=~ s[\..+$][];
  $name=(split m[/],$name)[-1];

  asm($name,$path);

# ---   *   ---   *   ---
# make structs from input blocks

  my @structs=(
    get_program_ubos(),
    get_program_ssbos()

  );

  goto MAKE_HEADER if !@structs;

  push @Out_Lines,
    'namespace shader::'.$path."::st {";

  for my $s(@structs) {

    $s->{value}='typedef struct';
    for my $leaf(@{$s->{leaves}}) {
      last if $leaf->{value} eq '{';

      $s->pluck($leaf);

    };

    $s->deep_value_repl(qr{^flat$},$NULLSTR);
    $s->deep_value_repl(qr{^uint$},'uint32_t');
    $s->deep_value_repl(qr{^int$},'int32_t');

    push @Out_Lines,
      $s->to_string(keep_root=>1).';';

  };

  push @Out_Lines, "}";

# ---   *   ---   *   ---
# create hpp file

MAKE_HEADER:

  my %O=(

    add_guards=>1,

    include=>[
      '"sin/shader/Params.hpp"',
      keys %Out_Include

    ],

    define=>[],

    author=>get_author(),

  );

  unshift @Out_Lines,
    Emit::C->boiler_open($name,%O);

  push @Out_Lines,
    Emit::C->boiler_close($name,%O);

  # remind the user who's daddy
  unshift @Out_Lines,@sig;

# ---   *   ---   *   ---
# spit it

  my $out=join "\n",@Out_Lines;

  $out=~ s[

    \#ifdef \s+ __cplusplus
    [^\#]+
    \#endif

  ][]sxmg;

  if($M->{echo} eq $NULL) {
    owc("$Out_Dir/$name.hpp",$out);

  } else {
    say $out;

  };

  # flush
  @Out_Lines=();
  %Out_Include=();

};

# ---   *   ---   *   ---
1; # ret

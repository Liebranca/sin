#!/usr/bin/perl
# ---   *   ---   *   ---
# SHADE
# Makes SIN shader blocks
#
# LIBRE SOFTWARE
# Licensed under GNU GPL3
# be a bro and inherit
#
# CONTRIBUTORS
# lyeb,
# ---   *   ---   *   ---

# deps
  use strict;
  use warnings;

  use lib $ENV{'ARPATH'}.'/lib/';
  use avt;
  use Cwd;

# ---   *   ---   *   ---
# global state

  my %CACHE=(
    'INCLUDE'  => [],

    'VERT_SRC' => [],
    'FRAG_SRC' => [],

    'ATTRS'    => [],
    'UNIFORMS' => [],
    'UBOS'     => [],
    'SSBOS'    => [],
    'SAMPLERS' => [],

    'FRAGINS'  => [],

  );

# ---   *   ---   *   ---
# appends to search path

sub stinc {

  my $path=shift;

  $path=~ s/\-I//;
  $path=Cwd::abs_path($path);

  my $ref=$CACHE{'INCLUDE'};
  push @$ref,$path;

};


# ---   *   ---   *   ---

sub ffind {
  my $fname=shift;
  my $src=undef;
  my $inc_ref=$CACHE{'INCLUDE'};
  my $path=undef;

  for $path(@$inc_ref) {

    if(!$path) {next;};

    if(-e "$path/$fname") {
      $src="$path/$fname";
      last;

    };

  };

  if(!$src) {
    print "Could not find $fname\n";
    exit;

  };

  return ($src,$path);

};

# ---   *   ---   *   ---
# find/read shader blocks

sub rdmeta {

  my $fwat=shift;
  my ($src,$path)=ffind "shblk.m";

  my @meta=split "\n",`cat $src`;
  while(@meta) {

    my $name=shift @meta;

    # if block found, copy data
    if($name eq $fwat) {
      for(my $i=0;$i<6;$i++) {
        my @data=split ' ',(shift @meta);
        my $key=shift @data;

        my $ref=$CACHE{$key};

        while(@data) {
          my $item=shift @data;
          if($key eq 'FRAGINS') {
            $item=~ s/\$/ /g;

          };if(!($item eq "None")) {
            push @$ref,$item;

          };

        };
      };

    # else skip
    };for(my $i=0;$i<6;$i++) {
      shift @meta;

    };
  };
};

# ---   *   ---   *   ---

sub parse_inc {
  my $clause=shift;
  $clause=~ s/\#include\s*\<//;
  $clause=~ s/\>//;

  my $name=$clause;
  $name=~ s/\.[\w|\d]*//;

  rdmeta $name;
  return "sh_blk_$name,\n";

};

# ---   *   ---   *   ---
# looks for special decls

sub is_decl {

  my $line=shift;
  my $ref=undef;

  if(($line=~ m/in\s+/)) {
    $line=~ s/in\s+//;

    if(($line=~ m/sampler.*\s+/)) {
      $line=~ s/sampler.*\s+//;
      $line=~ s/\;//;

      $ref=$CACHE{'SAMPLERS'};

    };

  } elsif(($line=~ m/out\s+/)
    || ($line=~ m/flat\s+out\s+/)

  ) {

    $line=~ s/out\s+//;
    my $in='in ';

    if(($line=~ m/flat\s+/)) {
      $line=~ s/flat\s+//;
      $in='flat in ';

    };$line=$in.$line;
    $line=~ s/\s/\$/g;
    $ref=$CACHE{'FRAGINS'};

  };if($ref) {
    push @$ref,$line;

  };


};

# ---   *   ---   *   ---
# in glsl, out C

sub compch {

  my $top=glob($_[0]);
  my %h=%{ avt::walk($top) };

  my $outc='';
  my $outh='';
  my $outm='';

  # find glsl files and iter thru
  for my $path(keys %h) {
    my @files=grep m/\.glsl/,@{ $h{$path} };
    for my $fname(@files) {

      $path=($path eq '<main>')
        ? $top
        : $path
        ;

      my $src="$path/$fname";

      my $name=$fname;
      $name=~ s/\.[\w|\d]*//;

      $outh.="extern const char* sh_blk_$name;\n";
      $outc.="const char* sh_blk_$name=\n";

# ---   *   ---   *   ---

      # read each file and get meta
      open SRC,'<',$src or die $!;
      while((my $line=readline SRC)) {
        chomp $line;if($line) {

          is_decl $line;
          $outc.="\"$line\\n\"\n";

        };
      };close SRC;
      $outc.=";\n";

# ---   *   ---   *   ---

      $outm.="$name\n";

      # save meta to var and cache wipe
      for my $i(
        'ATTRS',
        'UNIFORMS',
        'UBOS',
        'SSBOS',
        'SAMPLERS',
        'FRAGINS'

      ) {

        my @data=@{ $CACHE{$i} };

        $outm.=(@data)
          ? "$i ".(join ' ',@data)."\n"
          : "$i None\n"
          ;

        ;$CACHE{$i}=[];

      };

    };
  };

# ---   *   ---   *   ---

  # write out to disk
  open OUT,'>',"$top/shblk.c";
  print OUT $outc;

  close OUT;

  open OUT,'>',"$top/shblk.h";
  print OUT $outh;

  close OUT;

  open OUT,'>',"$top/shblk.m";
  print OUT $outm;

  close OUT;

};

# ---   *   ---   *   ---
# in sin glsl, out sin shaderParams

sub compsg {

  my $fname=shift;
  my ($src,$path)=ffind $fname;

  my $name=$fname;
  $name=~ s/\.[\w|\d]*//;

  my $out='';

# ---   *   ---   *   ---

  open SRC,'<',$src or die $!;
  while((my $line=readline SRC)) {

    chomp $line;

    if($line eq '$:VERT;>') {
      $out.='const char* vert_src[]={'."\n";
      $line='';

    } elsif($line eq '$:FRAG;>') {
      $out.="};\n";

      my $ref=$CACHE{'FRAGINS'};

      $out.='const char* frag_src[]={'."\n";
      while(@$ref) {
        my $item=shift @$ref;
        $out.="\"$item\\n\"\n";

      };

      $line='';

    } elsif($line=~ m/\#include/) {
      $line=parse_inc $line;

    } else {

      is_decl $line;

      $line=($line ne '')
        ? "\"$line\\n\"\n"
        : ''
        ;

    };if($line) {$out.=$line;};

  };close SRC;

# ---   *   ---   *   ---

  $out.="};\nconst SHDP pr_$name={\n";
  for my $ref(
    $CACHE{'ATTRS'},
    $CACHE{'UNIFORMS'},
    $CACHE{'UBOS'},
    $CACHE{'SSBOS'},
    $CACHE{'SAMPLERS'}

  ) {

    $out.="{";
    my $i=0;for my $item(@$ref) {
      $out.="\"$item\"";$i++;

      if($i<scalar(@$ref)) {
        $out.=',';

      };

    };$out.='},'.scalar(@$ref).",\n";

  };$out=substr $out,0,length($out)-2;
  $out.="\n};\n";
  print $out;

};

stinc('-I'.$ENV{'ARPATH'});
stinc('-I'.glob('.'));

compch('.');
compsg('test.sg');

# ---   *   ---   *   ---
1; # ret

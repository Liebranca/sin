// ---   *   ---   *   ---
// VERTEX
// Points in space
//
// LIBRE SOFTWARE
// Licensed under GNU GPL3
// be a bro and inherit
//
// CONTRIBUTORS
// lyeb,

// ---   *   ---   *   ---
// info

$:VERT;>

  VERSION   v0.00.3b;
  AUTHOR    "IBN-3DILA";

// ---   *   ---   *   ---
// inputs

  in uvec4 Vertex;

  uniform mat4 Model;
  uniform mat4 View;
  uniform mat4 Projection;

  layout (std430) buffer _Tile_Indices {
    uint buff[4096];

  } Tile_Indices;

// ---   *   ---   *   ---
// outputs

  out vec2 Tex_Coords;
  flat out uint Tile_Index;

// ---   *   ---   *   ---
// ROM

  const uint FRAC_MAXV[8]={
    0x01,0x03,0x07,0x0F,
    0x1F,0x3F,0x7F,0xFF

  };

  const float FRAC_STEP[8]={
    1.0f/0x0002,1.0f/0x0004,
    1.0f/0x0008,1.0f/0x0010,
    1.0f/0x0020,1.0f/0x0040,
    1.0f/0x0080,1.0f/0x0100

  };

// ---   *   ---   *   ---
// imagine these are enums ;>

  const uint FRAC_1BIT   = 0;
  const uint FRAC_2BIT   = 1;
  const uint FRAC_3BIT   = 2;
  const uint FRAC_4BIT   = 3;
  const uint FRAC_5BIT   = 4;
  const uint FRAC_6BIT   = 5;
  const uint FRAC_7BIT   = 6;
  const uint FRAC_8BIT   = 7;

  const bool FRAC_SIGNED = false;
  const bool FRAC_UNSIG  = true;

// ---   *   ---   *   ---
// see: bitter/kvrnel/Bytes.hpp

float unfrac(
  uint  b,
  float step,

  uint  nbits,
  bool  unsig

) {

  uint max=FRAC_MAXV[nbits];
  uint mid=1<<nbits;

  b&=max;

  b+=1*uint(b==max);
  b-=mid*uint(!unsig);

  return float(
    int(b)

  )*step;

};

// ---   *   ---   *   ---

float unfrac_i8(uint b) {

  return unfrac(

    b,

    FRAC_STEP[FRAC_8BIT],
    FRAC_8BIT,

    FRAC_SIGNED

  );

};

// ---   *   ---   *   ---

float unfrac_u8(uint b) {

  return unfrac(

    b,

    FRAC_STEP[FRAC_8BIT],
    FRAC_8BIT,

    FRAC_UNSIG

  );

};

// ---   *   ---   *   ---

vec2 extract_tex(void) {

  Tile_Index=Vertex[2]&0xFFFF;

  return vec2(

    unfrac_u8(Vertex[1]>>16),
    unfrac_u8(Vertex[1]>>24)

  );

};

// ---   *   ---   *   ---

vec4 extract_xyz(void) {

  return vec4(

    unfrac_i8(Vertex[0]),
    unfrac_i8(Vertex[0]>>8),
    unfrac_i8(Vertex[0]>>16),

    1

  );

};

// ---   *   ---   *   ---

vec4 apply_transform(vec4 co) {
  return Projection * View * Model * co;

};

// ---   *   ---   *   ---

$:FRAG;>

// ---   *   ---   *   ---
